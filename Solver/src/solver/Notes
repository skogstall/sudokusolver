Gillis gör rekursiva lösaren

   När användare matat in siffror i rutor och begärt att få se en lösning kan olika fall inträffa:
   • Det saknas lösning. Då ska programmet upptäcka och meddela detta.
   • Det finns flera lösningar. Då räcker det att programmet finner en lösning och presenterar
   denna.
   • Det finns en enda lösning. Då ska denna hittas och presenteras.
   Alla dessa fall kan hanteras av en rekursiv metod som använder backtracking. Metoden kan ha
   följande signatur:

   private boolean solve(int i, int j);

    För att lösa problemet startar man på rutan längst uppe till vänster, (0,0), vilket motsvarar ett
    anrop solve(0,0). För en enskild ruta (nedan kallad aktuell ruta) finns det två fall:

    1. Aktuell ruta är inte från början fylld (av användaren). Då provar man i tur och ordning
    att fylla den med något av talen 1..9. För varje sådant val kontrollerar man först att det är
    möjligt med hänsyn till reglerna för Sudoku. Om det är möjligt fyller man i rutan och gör
    ett rekursivt anrop för nästa ruta. Med nästa ruta avses här rutan till höger om aktuell ruta
    eller (om aktuell ruta är den sista på en rad) första rutan på nästa rad. Om det inte går att
    fylla aktuell ruta med något av alternativen eller om de rekursiva anropen returnerar false
    för alla de alternativ man provar, så markeras aktuell ruta som som ej ifylld (backtracking)
    och man returnerar false. Om däremot något av de rekursiva anropen returnerar true så
    har man hittat en lösning och kan returnera true.

    2. Aktuell ruta är från början fylld (av användaren). Då ska vi inte prova några alternativ utan
    bara kontrollera att det som är ifyllt är ok enligt reglerna. Om så är fallet görs ett rekursivt
    anrop för nästa ruta och resultatet av detta returneras. Om den ifyllda rutan däremot inte
    uppfyller villkoren har man misslyckats och returnerar false


För båda alternativen ovan gäller att om ”nästa ruta” inte finns (d.v.s. vi har gått igenom hela
rutnätet) så har vi lyckats fylla i alla rutor och kan returnera true.
Observera att den här lösningen medför att många alternativ ska provas. I vissa fall av olösliga
sudokun tar det mycket lång tid innan man får besked om iatt en lösning inte finns


        Lite ideer om hur jag ska gå tillväga

            Jag har en multidimensionell array (9, 9)

            Om man har en till multidimensionell av samma storlek, som har vilken rad och kolumn samt ruta varje index tillhår kan man ba referera till den i funktionen
            Den kan vara fylld av objekt som heter typ något typ "tileinfo" som har row, col och sections som data. de olika värdena är
            en array med koordinaterna i typ en touple för de raderna/kolumnerna/sektionerna. coords är en touple typ

            [][][] [][][] [][][]
            [][][] [][][] [][][]
            [][][] [][][] [][][]

            [][][] [][][] [][][]
            [][][] [][][] [][][]
            [][][] [][][] [][][]

            [][][] [][][] [][][]
            [][][] [][][] [][][]
            [][][] [][][] [][][]

        object Coords
            int x
            int y
            coords(x,y)
                set this.x = x
                set this.y = y
        object tile
            Lista<coords> cols
            Lista rows
            Lista section
            tile(x,y){
                coords = new Coords(x,y)

            }
            generateCol(y){
                lista 1 till 9
                for(i = ett till nio){
                    lägg till
                    coord(i,y)
                }
                returnera lista
            generateCol(x){
                lista 1 till 9
                for(i = ett till nio){
                    lägg till
                    coord(x,i)
                }
                returnera lista
            }
            generateSec(x,y){

                if(x är mellan 1 och 3)

            }



        Solve( x, y)
            Om x och y är ÖVER 9 9, returnera true
            annars
                (Uppdatera x och y till rätt värde, x1, y1)
                    om x inte är 9
                        x1 = x+1
                        y1 = y
                    annars
                        x1= 1
                        y1 = y+1

                Är den ifylld?
                nej

                    fyll i 1
                        checkvalid(x,y) och solve (x1, y1) är sant
                    annars fyll i 2
                        kolla samma
                    .... fortsätt till 9
                    annars
                        returnera false


                annars
                    om summan av raden upp och ned inte är för stor
                        och solve (x1, y1) är sant
                        returnera sant


        Hjälpmetod för att kolla om det funkar behövs nog

            CheckValid(x,y)

                om någon av dessa är falska, returnera falsk
                    checkList(tileinfo(x,y).cols
                    checkList(tileinfo(x,y).rows
                    checkList(tileinfo(x,y).sections
                annars true

            CheckList( lista med coords coordlist)
                skapa en lista med 9 platser
                skapa en index med platser
                skapa en bool
                for(coords in coordlist){
                    om platsen(sudoku(coord.x, coord.y) inte är null
                        fyll värdet (sudoku (coord.x coord.y))
                        index++
                }
                return Checkduplicates(lista);

            Checkduplicates(lista)
                om lista.toset.size < lista.size
                    returnera sant
                annars
                    returnera falskt


